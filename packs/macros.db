{"_id":"rVPgXQMZbcvB7jEz","name":"Calculate Range Increments","type":"script","author":"4siyeA20BbSN5bfQ","img":"modules/pf2e-ranged-combat/artwork/range-increment.webp","scope":"global","command":"/**\n * Macro to determine the range penalties to be applied based on the distance bwtween the controlled\n * token and the targeted token. Note that you must have exactly one controlled token (or one token\n * of your assigned character in the scene) and one targetted token to calculate the range penalties.\n * \n * If you already have any ranged penalties already applied, they will be removed first.\n * \n * The effect applied to your token is modified to only affect the relevant strike. If you have\n * more than one ranged strike ready, you will gain the effect for each strike separately.\n */\ncalculateRangeIncrement();\n\nasync function calculateRangeIncrement() {\n    const rangeIncrements = {\n        2: { desc: \"second\", itemId: \"Compendium.pf2e-ranged-combat.effects.dU7RDqMpPUQKhUK8\" },\n        3: { desc: \"third\", itemId: \"Compendium.pf2e-ranged-combat.effects.TAL4IhfswaglWGRg\" },\n        4: { desc: \"fourth\", itemId: \"Compendium.pf2e-ranged-combat.effects.4xqB3op2Gmy72civ\" },\n        5: { desc: \"fifth\", itemId: \"Compendium.pf2e-ranged-combat.effects.P0XsocGrdldNL3Ml\" },\n        6: { desc: \"sixth\", itemId: \"Compendium.pf2e-ranged-combat.effects.sqBuYhfwzyotmbBG\" }\n    };\n\n    // Find the currently controlled token, if there is one\n    const myToken = getControlledToken();\n    if (!myToken) {\n        return;\n    }\n\n    // Remove any range increment effects already on the token\n    let hasRemovedExistingEffect = false;\n    for (let key = 2; key <= 6; key++) {\n        let rangeIncrementId = rangeIncrements[key];\n        const existing = myToken.actor.itemTypes.effect.find((effect) =>\n            effect.getFlag('pf2e-ranged-combat', 'sourceId') === rangeIncrementId.itemId\n        );\n        if (existing) {\n            existing.delete();\n            hasRemovedExistingEffect = true;\n        }\n    }\n\n    // Find the currently targetted token, if there is one\n    const targetToken = getTarget(hasRemovedExistingEffect);\n    if (!targetToken) {\n        return;\n    }\n\n    // Find the weapon to apply the penalty to\n    let weapons = getWeapons(myToken);\n    if (!weapons.length) {\n        return;\n    }\n\n    // Calculate the distance between the controlled and targetted tokens, measured on the grid, and then\n    // which range increment of the weapon the target is in\n    const distance = canvas.grid.measureDistance(myToken.center, targetToken.center, { gridSpaces: true });\n\n    for (weapon of weapons) {\n        const rangeIncrement = Math.ceil(distance / weapon.data.range);\n\n        if (rangeIncrement < 2) {\n            continue;\n        } else if (rangeIncrement > 6) {\n            continue;\n        }\n\n        let rangeIncrementId = rangeIncrements[rangeIncrement];\n        const rangeIncrementEffect = await getItem(rangeIncrementId.itemId);\n        rangeIncrementEffect.data.rules[0].selector = `${weapon._id}-attack`;\n        rangeIncrementEffect.name = `${rangeIncrementEffect.name} (${weapon.name})`;\n\n        myToken.actor.createEmbeddedDocuments('Item', [rangeIncrementEffect]);\n    }\n\n    ui.notifications.info(`Calculated range increments for attack from ${myToken.name} to ${targetToken.name} (${distance} ft.)`);\n}\n\nfunction getControlledToken() {\n    const myTokens = canvas.tokens.controlled;\n    if (!myTokens.length) {\n        let myCharacter = game.user.character;\n        if (game.user.character) {\n            let userTokens = myCharacter.getActiveTokens();\n            if (!userTokens.length) {\n                ui.notifications.warn(\"No token selected\");\n                return;\n            } else if (userTokens.length > 1) {\n                ui.notifications.warn(\"More than one current character token\");\n                return;\n            } else {\n                return userTokens[0];\n            }\n        } else {\n            ui.notifications.warn(\"No token selected\");\n            return;\n        }\n    } else if (myTokens.length > 1) {\n        ui.notifications.warn(\"You must have only one token selected\");\n        return;\n    } else {\n        let myToken = myTokens[0];\n        if (![\"character\", \"npc\"].includes(myToken.actor.type)) {\n            ui.notifications.warn(\"You must have a character selected\");\n            return;\n        }\n        return myToken;\n    }\n}\n\n/**\n * Try to find exactly one targetted token\n * \n * @param {boolean} hasRemovedExistingEffect If we've removed an existing effect, don't give a warning\n *                                           about no targetted token, just exit silently.\n * @returns The currently targetted token, if there is exactly one\n */\nfunction getTarget(hasRemovedExistingEffect) {\n    const targetTokenIds = game.user.targets.ids;\n    const targetTokens = canvas.tokens.placeables.filter(token => targetTokenIds.includes(token.id));\n    if (!targetTokens.length) {\n        if (!hasRemovedExistingEffect) {\n            ui.notifications.warn(\"No target selected\");\n        }\n    } else if (targetTokens.length > 1) {\n        if (!hasRemovedExistingEffect) {\n            ui.notifications.warn(\"You must have only one target selected\");\n        }\n    } else {\n        return targetTokens[0];\n    }\n}\n\nfunction getWeapons(token) {\n    let weapons;\n\n    let strikes = token.actor.data.data.actions.filter(action => action.type === \"strike\");\n    if (token.actor.type == \"character\") {\n        // Characters' strikes, even thos granted by feats, all have weapon data associated with them, so we can find any associated with ranged weapons\n        weapons = strikes.filter(action => action.ready).map(action => action.weapon.data).filter(weapon => weapon.data.range);\n    } else if (token.actor.type == \"npc\") {\n        // NPCs' strikes don't have weapon data, but ranged options will have a range-increment-x trait\n        // Coerce the data to have everything we need, with the same structure as a PC's weapon data\n        weapons = strikes.filter(action => action.traits.filter(trait => trait.name.startsWith(\"range-increment-\")).length).map(strike => {\n            return {\n                _id: strike.sourceId,\n                name: strike.name,\n                img: strike.imageUrl,\n                data: {\n                    range: strike.traits.filter(trait => trait.name.startsWith(\"range-increment-\"))[0].name.slice(16)\n                }\n            }\n        });\n    }\n\n    if (!weapons.length) {\n        ui.notifications.info(`You have no ranged weapons equipped`);\n        return [];\n    } else {\n        return weapons;\n    }\n}\n\nasync function getItem(id) {\n    const source = (await fromUuid(id)).toObject();\n    source.flags[\"pf2e-ranged-combat\"] = {\n        sourceId: id\n    };\n    return source;\n}","folder":null,"sort":0,"permission":{"default":0,"4siyeA20BbSN5bfQ":3},"flags":{"core":{"sourceId":"Macro.30W2aLV7yIz2nfZ3"}}}
{"_id":"tMLBe6s8MjX8YVep","name":"Calculate Range Increment","type":"script","author":"4siyeA20BbSN5bfQ","img":"modules/pf2e-ranged-combat/artwork/range-increment.webp","scope":"global","command":"/**\n * Macro to determine the range penalty to be applied based on the distance from the controlled token\n * and the targeted token. Note that you must have exactly one controlled token (or one token of your\n * assigned character in the scene) and one targetted token to calculate the range penalty.\n * \n * If you have any ranged penalties already applied, they will be removed first.\n * \n * The effect applied to your token is modified to only affect the selected ranged strike. If you have\n * more than one ranged strike ready, you will be presented with a choice.\n */\n\n/**\n * Custom Dialog that shows a button for each available ranged strike\n */\nclass WeaponSelectDialog extends Dialog {\n    weaponId;\n    result;\n\n    constructor(content) {\n        super(\n            {\n                title: \"Weapon Select\",\n                content: content,\n                buttons: {\n                }\n            },\n            {\n                height: \"100%\",\n                width: \"100%\",\n                id: \"weapon-dialog\"\n            }\n        )\n    }\n\n    static async getWeapon(weapons) {\n        let content = `\n            <div class=\"weapon-buttons\" style=\"max-width: max-content; justify-items: center; margin: auto;\">\n            <p>Select Strike Weapon</p>\n        `\n        for (let weapon of weapons) {\n            content += `\n                <button class=\"weapon-button\" type=\"button\" value=\"${weapon._id}\" style=\"display: flex; align-items: center; margin: 4px auto\">\n                    <img src=\"${weapon.img}\" style=\"border: 1px solid #444; height: 1.6em; margin-right: 0.5em\"/>\n                    <span>${weapon.name}</span>\n                </button>\n            `\n        }\n        content += `</div>`\n        let weaponId = await new this(content).getWeaponId();\n        return weapons.filter(weapon => weapon._id === weaponId)[0];\n    }\n\n    activateListeners(html) {\n        html.find(\".weapon-button\").click(this.clickWeaponButton.bind(this));\n        super.activateListeners(html);\n    }\n\n    clickWeaponButton(event) {\n        this.weaponId = event.currentTarget.value;\n        this.close();\n    }\n\n    async close() {\n        this.result?.(this.weaponId);\n        await super.close();\n    }\n\n    async getWeaponId() {\n        this.render(true);\n        return new Promise(result => {\n            this.result = result;\n        });\n    }\n}\n\ncalculateRangeIncrement();\n\nasync function calculateRangeIncrement() {\n    const rangeIncrements = {\n        2: { desc: \"second\", itemId: \"Compendium.pf2e-ranged-combat.effects.dU7RDqMpPUQKhUK8\" },\n        3: { desc: \"third\", itemId: \"Compendium.pf2e-ranged-combat.effects.TAL4IhfswaglWGRg\" },\n        4: { desc: \"fourth\", itemId: \"Compendium.pf2e-ranged-combat.effects.4xqB3op2Gmy72civ\" },\n        5: { desc: \"fifth\", itemId: \"Compendium.pf2e-ranged-combat.effects.P0XsocGrdldNL3Ml\" },\n        6: { desc: \"sixth\", itemId: \"Compendium.pf2e-ranged-combat.effects.sqBuYhfwzyotmbBG\" }\n    };\n\n    // Find the currently controlled token, if there is one\n    const myToken = getControlledToken();\n    if (!myToken) {\n        return;\n    }\n\n    // Remove any range increment effects already on the token\n    let hasRemovedExistingEffect = false;\n    for (let key = 2; key <= 6; key++) {\n        let rangeIncrementId = rangeIncrements[key];\n        const existing = myToken.actor.itemTypes.effect.find((effect) =>\n            effect.getFlag('pf2e-ranged-combat', 'sourceId') === rangeIncrementId.itemId\n        );\n        if (existing) {\n            existing.delete();\n            hasRemovedExistingEffect = true;\n        }\n    }\n\n    // Find the currently targetted token, if there is one\n    const targetToken = getTarget(hasRemovedExistingEffect);\n    if (!targetToken) {\n        return;\n    }\n\n    // Find the weapon to apply the penalty to\n    let weapon = await getWeapon(myToken);\n    if (!weapon) {\n        return;\n    }\n\n    // Calculate the distance between the controlled and targetted tokens, measured on the grid, and then\n    // which range increment of the weapon the target is in\n    const distance = canvas.grid.measureDistance(myToken.center, targetToken.center, { gridSpaces: true });\n    const rangeIncrement = Math.ceil(distance / weapon.data.range);\n\n    if (rangeIncrement < 2) {\n        ui.notifications.info(`Attack from ${myToken.name} to ${targetToken.name} is ${distance} ft, using ${weapon.name} with range increment ${weapon.data.range} ft. Attack is in the first range increment`);\n        return;\n    } else if (rangeIncrement > 6) {\n        ui.notifications.error(`Attack from ${myToken.name} to ${targetToken.name} is ${distance} ft, using ${weapon.name} with range increment ${weapon.data.range} ft. Attack is past the sixth range increment and cannot be made`);\n        return;\n    }\n\n    let rangeIncrementId = rangeIncrements[rangeIncrement];\n    const rangeIncrementEffect = await getItem(rangeIncrementId.itemId);\n    rangeIncrementEffect.data.rules[0].selector = `${weapon._id}-attack`;\n    rangeIncrementEffect.name = `${rangeIncrementEffect.name} (${weapon.name})`;\n\n    ui.notifications.info(`Attack from ${myToken.name} to ${targetToken.name} is ${distance} ft, using ${weapon.name} with range increment ${weapon.data.range} ft. Attack is in the ${rangeIncrementId.desc} range increment`);\n\n    await myToken.actor.createEmbeddedDocuments('Item', [rangeIncrementEffect]);\n}\n\nfunction getControlledToken() {\n    const myTokens = canvas.tokens.controlled;\n    if (!myTokens.length) {\n        let myCharacter = game.user.character;\n        if (game.user.character) {\n            let userTokens = myCharacter.getActiveTokens();\n            if (!userTokens.length) {\n                ui.notifications.warn(\"No token selected\");\n                return;\n            } else if (userTokens.length > 1) {\n                ui.notifications.warn(\"More than one current character token\");\n                return;\n            } else {\n                return userTokens[0];\n            }\n        } else {\n            ui.notifications.warn(\"No token selected\");\n            return;\n        }\n    } else if (myTokens.length > 1) {\n        ui.notifications.warn(\"You must have only one token selected\");\n        return;\n    } else {\n        let myToken = myTokens[0];\n        if (![\"character\", \"npc\"].includes(myToken.actor.type)) {\n            ui.notifications.warn(\"You must have a character selected\");\n            return;\n        }\n        return myToken;\n    }\n}\n\n/**\n * Try to find exactly one targetted token\n * \n * @param {boolean} hasRemovedExistingEffect If we've removed an existing effect, don't give a warning\n *                                           about no targetted token, just exit silently.\n * @returns The currently targetted token, if there is exactly one\n */\nfunction getTarget(hasRemovedExistingEffect) {\n    const targetTokenIds = game.user.targets.ids;\n    const targetTokens = canvas.tokens.placeables.filter(token => targetTokenIds.includes(token.id));\n    if (!targetTokens.length) {\n        if (!hasRemovedExistingEffect) {\n            ui.notifications.warn(\"No target selected\");\n        }\n    } else if (targetTokens.length > 1) {\n        if (!hasRemovedExistingEffect) {\n            ui.notifications.warn(\"You must have only one target selected\");\n        }\n    } else {\n        return targetTokens[0];\n    }\n}\n\nasync function getWeapon(token) {\n    let weapons;\n\n    let strikes = token.actor.data.data.actions.filter(action => action.type === \"strike\");\n    if (token.actor.type == \"character\") {\n        // Characters' strikes, even thos granted by feats, all have weapon data associated with them, so we can find any associated with ranged weapons\n        weapons = strikes.filter(action => action.ready).map(action => action.weapon.data).filter(weapon => weapon.data.range);\n    } else if (token.actor.type == \"npc\") {\n        // NPCs' strikes don't have weapon data, but ranged options will have a range-increment-x trait\n        // Coerce the data to have everything we need, with the same structure as a PC's weapon data\n        weapons = strikes.filter(action => action.traits.filter(trait => trait.name.startsWith(\"range-increment-\")).length).map(strike => {\n            return {\n                _id: strike.sourceId,\n                name: strike.name,\n                img: strike.imageUrl,\n                data: {\n                    range: strike.traits.filter(trait => trait.name.startsWith(\"range-increment-\"))[0].name.slice(16)\n                }\n            }\n        });\n    }\n\n    if (!weapons.length) {\n        ui.notifications.info(`You have no ranged weapons equipped`);\n    } else if (weapons.length == 1) {\n        return weapons[0];\n    } else {\n        return chooseWeapon(weapons);\n    }\n}\n\nasync function chooseWeapon(weapons) {\n    let weapon = await WeaponSelectDialog.getWeapon(weapons);\n    if (!weapon) {\n        ui.notifications.warn(\"No weapon selected\");\n    }\n    return weapon;\n}\n\nasync function getItem(id) {\n    const source = (await fromUuid(id)).toObject();\n    source.flags[\"pf2e-ranged-combat\"] = {\n        sourceId: id\n    };\n    return source;\n}","folder":null,"sort":0,"permission":{"default":0,"4siyeA20BbSN5bfQ":3},"flags":{"core":{"sourceId":"Macro.dBWZBfBIjXD6BqFZ"}}}
