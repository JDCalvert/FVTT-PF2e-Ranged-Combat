{"_id":"ddmh8XdH0dbq3POz","name":"Hunt Prey","type":"script","author":"I90qJ09IMT0McqwG","img":"systems/pf2e/icons/features/classes/hunt-prey.webp","scope":"global","command":"reload();\n\nasync function reload() {\n    const HUNT_PREY_FEATURE_ID = \"Compendium.pf2e.classfeatures.0nIOGpHQNHsKSFKT\";\n    const HUNT_PREY_ACTION_ID = \"Compendium.pf2e.actionspf2e.JYi4MnsdFu618hPm\";\n    const HUNTED_PREY_EFFECT_ID = \"Compendium.pf2e-ranged-combat.effects.rdLADYwOByj8AZ7r\";\n    const CROSSBOW_ACE_FEAT_ID = \"Compendium.pf2e.feats-srd.CpjN7v1QN8TQFcvI\";\n    const CROSSBOW_ACE_EFFECT_ID = \"Compendium.pf2e-ranged-combat.effects.zP0vPd14V5OG9ZFv\";\n\n    const effectsToAdd = [];\n\n    const myToken = getControlledToken();\n    if (!myToken) {\n        ui.notifications.warn(\"You must have exactly one token selected, or your assigned character must have one token\")\n        return;\n    }\n\n    if (!actorHasItem(myToken, HUNT_PREY_FEATURE_ID)) {\n        ui.notifications.warn(\"You do not have the Hunt Prey feature\");\n        return;\n    }\n\n    const target = getTarget();\n    if (!target) {\n        return;\n    }\n\n    /**\n     * HUNT PREY ACTION AND EFFECT\n     */\n    {\n        const myHuntPreyAction = await getItemFromActor(myToken, HUNT_PREY_ACTION_ID, true);\n        myHuntPreyAction.toMessage();\n\n        // Remove any existing hunted prey effects\n        const existing = await getItemFromActor(myToken, HUNTED_PREY_EFFECT_ID);\n        if (existing) await existing.delete();\n\n        // Add the new effect\n        const huntedPreyEffect = await getItem(HUNTED_PREY_EFFECT_ID);\n        huntedPreyEffect.name = `${huntedPreyEffect.name} (${target.name})`;\n        huntedPreyEffect.flags[\"pf2e-ranged-combat\"] = {\n            targetId: target.id\n        };\n        effectsToAdd.push(huntedPreyEffect);\n\n        // Set the Hunt Prey flag, since we're currently targetting our hunted prey\n        myToken.actor.setFlag(\"pf2e\", \"rollOptions.all.hunted-prey\", true)\n    }\n\n    /**\n     * CROSSBOW ACE\n     */\n    {\n        if (actorHasItem(myToken, CROSSBOW_ACE_FEAT_ID)) {\n            let weapons = await getWeapons(myToken);\n\n            for (const weapon of weapons) {\n                const existing = await getEffectFromActor(myToken, CROSSBOW_ACE_EFFECT_ID, weapon._id);\n                if (existing) await existing.delete();\n\n                const effect = await getItem(CROSSBOW_ACE_EFFECT_ID);\n                setEffectTarget(effect, weapon);\n\n                // Until DamageDice \"upgrade\" is in the system, we have to hack it\n                const damageDieRule = effect.data.rules.find(rule => rule.key === \"DamageDice\");\n                damageDieRule.override.dieSize = getNextDieSize(weapon.data.damage.die);\n\n                effectsToAdd.push(effect);\n            }\n        }\n    }\n\n    myToken.actor.createEmbeddedDocuments(\"Item\", effectsToAdd);\n}\n\nfunction getControlledToken() {\n    return [canvas.tokens.controlled, game.user.character?.getActiveTokens()]\n        .filter(tokens => !!tokens)\n        .find(tokens => tokens.length === 1)\n        ?.[0];\n}\n\nfunction getTarget() {\n    const targetTokenIds = game.user.targets.ids;\n    const targetTokens = canvas.tokens.placeables.filter(token => targetTokenIds.includes(token.id));\n    if (!targetTokens.length) {\n        ui.notifications.warn(\"No target selected\");\n    } else if (targetTokens.length > 1) {\n        ui.notifications.warn(\"You must have only one target selected\");\n    } else {\n        return targetTokens[0];\n    }\n}\n\nfunction getWeapons(token) {\n    return token.actor.itemTypes.weapon\n        .map(weapon => weapon.data)\n        .filter(weapon => weapon.data.equipped.value)\n        .filter(weapon => weapon.data.traits.otherTags.includes(\"crossbow\"));\n}\n\nfunction actorHasItem(token, sourceId) {\n    return token.actor.items.some(item => item.getFlag(\"core\", \"sourceId\") === sourceId);\n}\n\nasync function getItemFromActor(token, sourceId, addIfNotPresent = false) {\n    let myItem = token.actor.items.find(item => item.getFlag(\"core\", \"sourceId\") === sourceId);\n    if (!myItem && addIfNotPresent) {\n        const newItem = await getItem(sourceId);\n        await token.actor.createEmbeddedDocuments(\"Item\", [newItem]);\n        myItem = await getItemFromActor(token, sourceId);\n    }\n    return myItem;\n}\n\nfunction getEffectFromActor(token, sourceId, targetId) {\n    return token.actor.itemTypes.effect.find(effect =>\n        effect.getFlag(\"core\", \"sourceId\") === sourceId\n        && effect.getFlag(\"pf2e-ranged-combat\", \"targetId\") === targetId\n    );\n}\n\nasync function getItem(id) {\n    const source = (await fromUuid(id)).toObject();\n    source.flags.core ??= {};\n    source.flags.core.sourceId = id;\n    source._id = randomID();\n    return source;\n}\n\nfunction setEffectTarget(effect, weapon) {\n    effect.name = `${effect.name} (${weapon.name})`;\n    effect.flags[\"pf2e-ranged-combat\"] = {\n        targetId: weapon._id\n    };\n\n    const rules = effect.data.rules;\n    const indexOfEffectTarget = rules.findIndex(rule =>\n        rule.key === \"EffectTarget\"\n    );\n    rules.splice(indexOfEffectTarget, 1);\n\n    rules.forEach(rule =>\n        rule.selector = rule.selector.replace(\"{item|data.target}\", weapon._id)\n    );\n}\n\nfunction getNextDieSize(dieSize) {\n    switch (dieSize) {\n        case \"d4\":\n            return \"d6\";\n        case \"d6\":\n            return \"d8\";\n        case \"d8\":\n            return \"d10\";\n        case \"d10\":\n            return \"d12\";\n        case \"d12\":\n            return \"d12\";\n    }\n}","folder":null,"sort":0,"permission":{"default":0,"I90qJ09IMT0McqwG":3},"flags":{}}
{"_id":"h8SWfgcKKwIEOwvJ","name":"Reload","type":"script","author":"I90qJ09IMT0McqwG","img":"systems/pf2e/icons/actions/OneAction.webp","scope":"global","command":"class WeaponSelectDialog extends Dialog {\n    weaponId;\n    result;\n\n    constructor(content) {\n        super(\n            {\n                title: \"Weapon Select\",\n                content: content,\n                buttons: {\n                }\n            },\n            {\n                height: \"100%\",\n                width: \"100%\",\n                id: \"weapon-dialog\"\n            }\n        )\n    }\n\n    static async getWeapon(weapons) {\n        let content = `\n            <div class=\"weapon-buttons\" style=\"max-width: max-content; justify-items: center; margin: auto;\">\n            <p>Select Weapon</p>\n        `\n        for (let weapon of weapons) {\n            content += `\n                <button class=\"weapon-button\" type=\"button\" value=\"${weapon._id}\" style=\"display: flex; align-items: center; margin: 4px auto\">\n                    <img src=\"${weapon.img}\" style=\"border: 1px solid #444; height: 1.6em; margin-right: 0.5em\"/>\n                    <span>${weapon.name}</span>\n                </button>\n            `\n        }\n        content += `</div>`\n        let weaponId = await new this(content).getWeaponId();\n        return weapons.filter(weapon => weapon._id === weaponId)[0];\n    }\n\n    activateListeners(html) {\n        html.find(\".weapon-button\").click(this.clickWeaponButton.bind(this));\n        super.activateListeners(html);\n    }\n\n    clickWeaponButton(event) {\n        this.weaponId = event.currentTarget.value;\n        this.close();\n    }\n\n    async close() {\n        this.result?.(this.weaponId);\n        await super.close();\n    }\n\n    async getWeaponId() {\n        this.render(true);\n        return new Promise(result => {\n            this.result = result;\n        });\n    }\n}\n\nreload();\n\nasync function reload() {\n    const RELOAD_ACTION_ONE_ID = \"Compendium.pf2e-ranged-combat.actions.MAYuLJ4bsciOXiNM\";\n    const RELOAD_ACTION_TWO_ID = \"Compendium.pf2e-ranged-combat.actions.lqjuYBOAjDb9ACfo\";\n    const LOADED_EFFECT_ID = \"Compendium.pf2e-ranged-combat.effects.nEqdxZMAHlYVXI0Z\";\n    const CROSSBOW_ACE_FEAT_ID = \"Compendium.pf2e.feats-srd.CpjN7v1QN8TQFcvI\";\n    const CROSSBOW_ACE_EFFECT_ID = \"Compendium.pf2e-ranged-combat.effects.zP0vPd14V5OG9ZFv\";\n    const CROSSBOW_CRACK_SHOT_FEAT_ID = \"Compendium.pf2e.feats-srd.s6h0xkdKf3gecLk6\";\n    const CROSSBOW_CRACK_SHOT_EFFECT_ID = \"Compendium.pf2e-ranged-combat.effects.hG9i3aOBDZ9Bq9yi\";\n\n    const effectsToAdd = [];\n\n    const myToken = getControlledToken();\n    if (!myToken) {\n        ui.notifications.warn(\"You must have exactly one token selected, or your assigned character must have one token\")\n        return;\n    }\n\n    let weapon = await getWeapon(myToken);\n    if (!weapon) {\n        return;\n    }\n\n    // Check if this weapon is already loaded\n    const myLoadedEffect = myToken.actor.itemTypes.effect.find(effect =>\n        effect.getFlag(\"core\", \"sourceId\") === LOADED_EFFECT_ID\n        && effect.getFlag(\"pf2e-ranged-combat\", \"weaponId\") === weapon._id\n    );\n    if (myLoadedEffect) {\n        ui.notifications.warn(`${weapon.name} is already loaded`);\n        return;\n    }\n\n    // If we don't already have it, add the reload action, and then post it\n    const reloadActions = weapon.data.reload.value;\n    const reloadActionId = (() => {\n        switch (reloadActions) {\n            case \"1\":\n                return RELOAD_ACTION_ONE_ID;\n            case \"2\":\n                return RELOAD_ACTION_TWO_ID;\n            default:\n                return RELOAD_ACTION_ONE_ID;\n        }\n    })();\n    const reloadAction = await getItem(reloadActionId);\n    let myReloadAction = myToken.actor.itemTypes.action.find(action =>\n        action.getFlag(\"core\", \"sourceId\") === reloadActionId\n    );\n    if (!myReloadAction) {\n        await myToken.actor.createEmbeddedDocuments(\"Item\", [reloadAction]);\n        myReloadAction = myToken.actor.itemTypes.action.find(action =>\n            action.getFlag(\"core\", \"sourceId\") === reloadActionId\n        );\n    }\n    myReloadAction.toMessage();\n\n    // Get the \"Loaded\" effect and set its target to the weapon we're reloading\n    const loadedEffect = await getItem(LOADED_EFFECT_ID);\n    setEffectTarget(loadedEffect, weapon);\n    effectsToAdd.push(loadedEffect);\n\n    // Handle crossbow effects that trigger on reload\n    const weaponIsCrossbow = weapon.data.traits.otherTags.includes(\"crossbow\");\n    const weaponIsEquipped = weapon.data.equipped.value;\n    if (weaponIsCrossbow && weaponIsEquipped) {\n        const crossbowFeats = [\n            {\n                featId: CROSSBOW_ACE_FEAT_ID,\n                effectId: CROSSBOW_ACE_EFFECT_ID\n            },\n            {\n                featId: CROSSBOW_CRACK_SHOT_FEAT_ID,\n                effectId: CROSSBOW_CRACK_SHOT_EFFECT_ID\n            }\n        ]\n\n        for (const crossbowFeat of crossbowFeats) {\n            const featId = crossbowFeat.featId;\n            const effectId = crossbowFeat.effectId;\n\n            const hasFeat = myToken.actor.itemTypes.feat.some(feat =>\n                feat.data.flags.core.sourceId === featId\n            );\n\n            if (hasFeat) {\n                // Remove any existing effects\n                const existing = myToken.actor.itemTypes.effect.find(effect =>\n                    effect.getFlag('core', 'sourceId') === effectId\n                    && effect.getFlag(\"pf2e-ranged-combat\", \"weaponId\") === weapon._id\n                );\n                if (existing) {\n                    await existing.delete();\n                }\n\n                // Add the new effect\n                const effect = await getItem(effectId);\n                setEffectTarget(effect, weapon);\n\n                // Until DamageDice \"upgrade\" is in the system, we have to hack it\n                const damageDieRule = effect.data.rules.find(rule => rule.key === \"DamageDice\");\n                damageDieRule.override.dieSize = getNextDieSize(weapon.data.damage.die);\n\n                effectsToAdd.push(effect);\n            }\n        }\n    }\n\n    myToken.actor.createEmbeddedDocuments(\"Item\", effectsToAdd);\n}\n\nfunction getControlledToken() {\n    return [canvas.tokens.controlled, game.user.character?.getActiveTokens()]\n        .filter(tokens => !!tokens)\n        .find(tokens => tokens.length === 1)\n        ?.[0];\n}\n\nasync function getWeapon(token) {\n    let weapons = token.actor.itemTypes.weapon.map(weapon => weapon.data).filter(weapon => weapon.data.reload.value > 0);\n    if (!weapons.length) {\n        ui.notifications.info(`You have no ranged weapons equipped`);\n    } else if (weapons.length == 1) {\n        return weapons[0];\n    } else {\n        return chooseWeapon(weapons);\n    }\n}\n\nasync function chooseWeapon(weapons) {\n    let weapon = await WeaponSelectDialog.getWeapon(weapons);\n    if (!weapon) {\n        ui.notifications.warn(\"No weapon selected\");\n    }\n    return weapon;\n}\n\nasync function getItem(id) {\n    const source = (await fromUuid(id)).toObject();\n    source.flags.core ??= {};\n    source.flags.core.sourceId = id;\n    source._id = randomID();\n    return source;\n}\n\nfunction setEffectTarget(effect, weapon) {\n    effect.name = `${effect.name} (${weapon.name})`;\n    effect.flags[\"pf2e-ranged-combat\"] = {\n        weaponId: weapon._id\n    };\n    \n    const rules = effect.data.rules;\n    const indexOfEffectTarget = rules.findIndex(rule =>\n        rule.key === \"EffectTarget\"\n    );\n    rules.splice(indexOfEffectTarget, 1);\n\n    rules.forEach(rule =>\n        rule.selector = rule.selector.replace(\"{item|data.target}\", weapon._id)\n    );\n}\n\nfunction getNextDieSize(dieSize) {\n    switch (dieSize) {\n        case \"d4\":\n            return \"d6\";\n        case \"d6\":\n            return \"d8\";\n        case \"d8\":\n            return \"d10\";\n        case \"d10\":\n            return \"d12\";\n        case \"d12\":\n            return \"d12\";\n    }\n}","folder":null,"sort":0,"permission":{"default":0,"I90qJ09IMT0McqwG":3},"flags":{}}
{"_id":"rVPgXQMZbcvB7jEz","name":"Calculate Range Increments","type":"script","author":"4siyeA20BbSN5bfQ","img":"modules/pf2e-ranged-combat/artwork/range-increment.webp","scope":"global","command":"/**\n * Macro to determine the range penalties to be applied based on the distance bwtween the controlled\n * token and the targeted token. Note that you must have exactly one controlled token (or one token\n * of your assigned character in the scene) and one targetted token to calculate the range penalties.\n * \n * If you already have any ranged penalties already applied, they will be removed first.\n * \n * The effect applied to your token is modified to only affect the relevant strike. If you have\n * more than one ranged strike ready, you will gain the effect for each strike separately.\n */\ncalculateRangeIncrement();\n\nasync function calculateRangeIncrement() {\n    const rangeIncrements = {\n        2: { desc: \"second\", itemId: \"Compendium.pf2e-ranged-combat.effects.dU7RDqMpPUQKhUK8\" },\n        3: { desc: \"third\", itemId: \"Compendium.pf2e-ranged-combat.effects.TAL4IhfswaglWGRg\" },\n        4: { desc: \"fourth\", itemId: \"Compendium.pf2e-ranged-combat.effects.4xqB3op2Gmy72civ\" },\n        5: { desc: \"fifth\", itemId: \"Compendium.pf2e-ranged-combat.effects.P0XsocGrdldNL3Ml\" },\n        6: { desc: \"sixth\", itemId: \"Compendium.pf2e-ranged-combat.effects.sqBuYhfwzyotmbBG\" }\n    };\n\n    // Find the currently controlled token, if there is one\n    const myToken = getControlledToken();\n    if (!myToken) {\n        return;\n    }\n\n    // Remove any range increment effects already on the token\n    let hasRemovedExistingEffect = false;\n    for (let key = 2; key <= 6; key++) {\n        let rangeIncrementId = rangeIncrements[key];\n        const existing = myToken.actor.itemTypes.effect.find((effect) =>\n            effect.getFlag('pf2e-ranged-combat', 'sourceId') === rangeIncrementId.itemId\n        );\n        if (existing) {\n            existing.delete();\n            hasRemovedExistingEffect = true;\n        }\n    }\n\n    // Find the currently targetted token, if there is one\n    const targetToken = getTarget(hasRemovedExistingEffect);\n    if (!targetToken) {\n        return;\n    }\n\n    // Find the weapon to apply the penalty to\n    let weapons = getWeapons(myToken);\n    if (!weapons.length) {\n        return;\n    }\n\n    // Calculate the distance between the controlled and targetted tokens, measured on the grid, and then\n    // which range increment of the weapon the target is in\n    const gridSize = canvas.dimensions.size;\n    const dx = Math.max(0, myToken.x - (targetToken.x + targetToken.w - gridSize), targetToken.x - (myToken.x + myToken.w - gridSize));\n    const dy = Math.max(0, myToken.y - (targetToken.y + targetToken.h - gridSize), targetToken.y - (myToken.y + myToken.h - gridSize));\n\n    const distance = canvas.grid.measureDistance({x: 0, y: 0}, {x: dx, y: dy}, { gridSpaces: true });\n\n    for (weapon of weapons) {\n        const rangeIncrement = Math.ceil(distance / weapon.data.range);\n\n        if (rangeIncrement < 2) {\n            continue;\n        } else if (rangeIncrement > 6) {\n            continue;\n        }\n\n        let rangeIncrementId = rangeIncrements[rangeIncrement];\n        const rangeIncrementEffect = await getItem(rangeIncrementId.itemId);\n        rangeIncrementEffect.data.rules[0].selector = `${weapon._id}-attack`;\n        rangeIncrementEffect.name = `${rangeIncrementEffect.name} (${weapon.name})`;\n\n        myToken.actor.createEmbeddedDocuments('Item', [rangeIncrementEffect]);\n    }\n\n    ui.notifications.info(`Calculated range increments for attack from ${myToken.name} to ${targetToken.name} (${distance} ft.)`);\n}\n\nfunction getControlledToken() {\n    const myTokens = canvas.tokens.controlled;\n    if (!myTokens.length) {\n        let myCharacter = game.user.character;\n        if (game.user.character) {\n            let userTokens = myCharacter.getActiveTokens();\n            if (!userTokens.length) {\n                ui.notifications.warn(\"No token selected\");\n                return;\n            } else if (userTokens.length > 1) {\n                ui.notifications.warn(\"More than one current character token\");\n                return;\n            } else {\n                return userTokens[0];\n            }\n        } else {\n            ui.notifications.warn(\"No token selected\");\n            return;\n        }\n    } else if (myTokens.length > 1) {\n        ui.notifications.warn(\"You must have only one token selected\");\n        return;\n    } else {\n        let myToken = myTokens[0];\n        if (![\"character\", \"npc\"].includes(myToken.actor.type)) {\n            ui.notifications.warn(\"You must have a character selected\");\n            return;\n        }\n        return myToken;\n    }\n}\n\n/**\n * Try to find exactly one targetted token\n * \n * @param {boolean} hasRemovedExistingEffect If we've removed an existing effect, don't give a warning\n *                                           about no targetted token, just exit silently.\n * @returns The currently targetted token, if there is exactly one\n */\nfunction getTarget(hasRemovedExistingEffect) {\n    const targetTokenIds = game.user.targets.ids;\n    const targetTokens = canvas.tokens.placeables.filter(token => targetTokenIds.includes(token.id));\n    if (!targetTokens.length) {\n        if (!hasRemovedExistingEffect) {\n            ui.notifications.warn(\"No target selected\");\n        }\n    } else if (targetTokens.length > 1) {\n        if (!hasRemovedExistingEffect) {\n            ui.notifications.warn(\"You must have only one target selected\");\n        }\n    } else {\n        return targetTokens[0];\n    }\n}\n\nfunction getWeapons(token) {\n    let weapons;\n\n    let strikes = token.actor.data.data.actions.filter(action => action.type === \"strike\");\n    if (token.actor.type == \"character\") {\n        // Characters' strikes, even thos granted by feats, all have weapon data associated with them, so we can find any associated with ranged weapons\n        weapons = strikes.filter(action => action.ready).map(action => action.weapon.data).filter(weapon => weapon.data.range);\n    } else if (token.actor.type == \"npc\") {\n        // NPCs' strikes don't have weapon data, but ranged options will have a range-increment-x trait\n        // Coerce the data to have everything we need, with the same structure as a PC's weapon data\n        weapons = strikes.filter(action => action.traits.filter(trait => trait.name.startsWith(\"range-increment-\")).length).map(strike => {\n            return {\n                _id: strike.sourceId,\n                name: strike.name,\n                img: strike.imageUrl,\n                data: {\n                    range: strike.traits.filter(trait => trait.name.startsWith(\"range-increment-\"))[0].name.slice(16)\n                }\n            }\n        });\n    }\n\n    if (!weapons.length) {\n        ui.notifications.info(`You have no ranged weapons equipped`);\n        return [];\n    } else {\n        return weapons;\n    }\n}\n\nasync function getItem(id) {\n    const source = (await fromUuid(id)).toObject();\n    source.flags[\"pf2e-ranged-combat\"] = {\n        sourceId: id\n    };\n    return source;\n}","folder":null,"sort":0,"permission":{"default":0,"4siyeA20BbSN5bfQ":3},"flags":{}}
{"_id":"tMLBe6s8MjX8YVep","name":"Calculate Range Increment","type":"script","author":"4siyeA20BbSN5bfQ","img":"modules/pf2e-ranged-combat/artwork/range-increment.webp","scope":"global","command":"/**\n * Macro to determine the range penalty to be applied based on the distance from the controlled token\n * and the targeted token. Note that you must have exactly one controlled token (or one token of your\n * assigned character in the scene) and one targetted token to calculate the range penalty.\n * \n * If you have any ranged penalties already applied, they will be removed first.\n * \n * The effect applied to your token is modified to only affect the selected ranged strike. If you have\n * more than one ranged strike ready, you will be presented with a choice.\n */\n\n/**\n * Custom Dialog that shows a button for each available ranged strike\n */\nclass WeaponSelectDialog extends Dialog {\n    weaponId;\n    result;\n\n    constructor(content) {\n        super(\n            {\n                title: \"Weapon Select\",\n                content: content,\n                buttons: {\n                }\n            },\n            {\n                height: \"100%\",\n                width: \"100%\",\n                id: \"weapon-dialog\"\n            }\n        )\n    }\n\n    static async getWeapon(weapons) {\n        let content = `\n            <div class=\"weapon-buttons\" style=\"max-width: max-content; justify-items: center; margin: auto;\">\n            <p>Select Strike Weapon</p>\n        `\n        for (let weapon of weapons) {\n            content += `\n                <button class=\"weapon-button\" type=\"button\" value=\"${weapon._id}\" style=\"display: flex; align-items: center; margin: 4px auto\">\n                    <img src=\"${weapon.img}\" style=\"border: 1px solid #444; height: 1.6em; margin-right: 0.5em\"/>\n                    <span>${weapon.name}</span>\n                </button>\n            `\n        }\n        content += `</div>`\n        let weaponId = await new this(content).getWeaponId();\n        return weapons.filter(weapon => weapon._id === weaponId)[0];\n    }\n\n    activateListeners(html) {\n        html.find(\".weapon-button\").click(this.clickWeaponButton.bind(this));\n        super.activateListeners(html);\n    }\n\n    clickWeaponButton(event) {\n        this.weaponId = event.currentTarget.value;\n        this.close();\n    }\n\n    async close() {\n        this.result?.(this.weaponId);\n        await super.close();\n    }\n\n    async getWeaponId() {\n        this.render(true);\n        return new Promise(result => {\n            this.result = result;\n        });\n    }\n}\n\ncalculateRangeIncrement();\n\nasync function calculateRangeIncrement() {\n    const rangeIncrements = {\n        2: { desc: \"second\", itemId: \"Compendium.pf2e-ranged-combat.effects.dU7RDqMpPUQKhUK8\" },\n        3: { desc: \"third\", itemId: \"Compendium.pf2e-ranged-combat.effects.TAL4IhfswaglWGRg\" },\n        4: { desc: \"fourth\", itemId: \"Compendium.pf2e-ranged-combat.effects.4xqB3op2Gmy72civ\" },\n        5: { desc: \"fifth\", itemId: \"Compendium.pf2e-ranged-combat.effects.P0XsocGrdldNL3Ml\" },\n        6: { desc: \"sixth\", itemId: \"Compendium.pf2e-ranged-combat.effects.sqBuYhfwzyotmbBG\" }\n    };\n\n    // Find the currently controlled token, if there is one\n    const myToken = getControlledToken();\n    if (!myToken) {\n        return;\n    }\n\n    // Remove any range increment effects already on the token\n    let hasRemovedExistingEffect = false;\n    for (let key = 2; key <= 6; key++) {\n        let rangeIncrementId = rangeIncrements[key];\n        const existing = myToken.actor.itemTypes.effect.find((effect) =>\n            effect.getFlag('pf2e-ranged-combat', 'sourceId') === rangeIncrementId.itemId\n        );\n        if (existing) {\n            existing.delete();\n            hasRemovedExistingEffect = true;\n        }\n    }\n\n    // Find the currently targetted token, if there is one\n    const targetToken = getTarget(hasRemovedExistingEffect);\n    if (!targetToken) {\n        return;\n    }\n\n    // Find the weapon to apply the penalty to\n    let weapon = await getWeapon(myToken);\n    if (!weapon) {\n        return;\n    }\n\n    // Calculate the distance between the controlled and targetted tokens, measured on the grid, and then\n    // which range increment of the weapon the target is in\n    const gridSize = canvas.dimensions.size;\n    const dx = Math.max(0, myToken.x - (targetToken.x + targetToken.w - gridSize), targetToken.x - (myToken.x + myToken.w - gridSize));\n    const dy = Math.max(0, myToken.y - (targetToken.y + targetToken.h - gridSize), targetToken.y - (myToken.y + myToken.h - gridSize));\n\n    const distance = canvas.grid.measureDistance({x: 0, y: 0}, {x: dx, y: dy}, { gridSpaces: true });\n    const rangeIncrement = Math.ceil(distance / weapon.data.range);\n\n    if (rangeIncrement < 2) {\n        ui.notifications.info(`Attack from ${myToken.name} to ${targetToken.name} is ${distance} ft, using ${weapon.name} with range increment ${weapon.data.range} ft. Attack is in the first range increment`);\n        return;\n    } else if (rangeIncrement > 6) {\n        ui.notifications.error(`Attack from ${myToken.name} to ${targetToken.name} is ${distance} ft, using ${weapon.name} with range increment ${weapon.data.range} ft. Attack is past the sixth range increment and cannot be made`);\n        return;\n    }\n\n    let rangeIncrementId = rangeIncrements[rangeIncrement];\n    const rangeIncrementEffect = await getItem(rangeIncrementId.itemId);\n    rangeIncrementEffect.data.rules[0].selector = `${weapon._id}-attack`;\n    rangeIncrementEffect.name = `${rangeIncrementEffect.name} (${weapon.name})`;\n\n    ui.notifications.info(`Attack from ${myToken.name} to ${targetToken.name} is ${distance} ft, using ${weapon.name} with range increment ${weapon.data.range} ft. Attack is in the ${rangeIncrementId.desc} range increment`);\n\n    await myToken.actor.createEmbeddedDocuments('Item', [rangeIncrementEffect]);\n}\n\nfunction getControlledToken() {\n    const myTokens = canvas.tokens.controlled;\n    if (!myTokens.length) {\n        let myCharacter = game.user.character;\n        if (game.user.character) {\n            let userTokens = myCharacter.getActiveTokens();\n            if (!userTokens.length) {\n                ui.notifications.warn(\"No token selected\");\n                return;\n            } else if (userTokens.length > 1) {\n                ui.notifications.warn(\"More than one current character token\");\n                return;\n            } else {\n                return userTokens[0];\n            }\n        } else {\n            ui.notifications.warn(\"No token selected\");\n            return;\n        }\n    } else if (myTokens.length > 1) {\n        ui.notifications.warn(\"You must have only one token selected\");\n        return;\n    } else {\n        let myToken = myTokens[0];\n        if (![\"character\", \"npc\"].includes(myToken.actor.type)) {\n            ui.notifications.warn(\"You must have a character selected\");\n            return;\n        }\n        return myToken;\n    }\n}\n\n/**\n * Try to find exactly one targetted token\n * \n * @param {boolean} hasRemovedExistingEffect If we've removed an existing effect, don't give a warning\n *                                           about no targetted token, just exit silently.\n * @returns The currently targetted token, if there is exactly one\n */\nfunction getTarget(hasRemovedExistingEffect) {\n    const targetTokenIds = game.user.targets.ids;\n    const targetTokens = canvas.tokens.placeables.filter(token => targetTokenIds.includes(token.id));\n    if (!targetTokens.length) {\n        if (!hasRemovedExistingEffect) {\n            ui.notifications.warn(\"No target selected\");\n        }\n    } else if (targetTokens.length > 1) {\n        if (!hasRemovedExistingEffect) {\n            ui.notifications.warn(\"You must have only one target selected\");\n        }\n    } else {\n        return targetTokens[0];\n    }\n}\n\nasync function getWeapon(token) {\n    let weapons;\n\n    let strikes = token.actor.data.data.actions.filter(action => action.type === \"strike\");\n    if (token.actor.type == \"character\") {\n        // Characters' strikes, even thos granted by feats, all have weapon data associated with them, so we can find any associated with ranged weapons\n        weapons = strikes.filter(action => action.ready).map(action => action.weapon.data).filter(weapon => weapon.data.range);\n    } else if (token.actor.type == \"npc\") {\n        // NPCs' strikes don't have weapon data, but ranged options will have a range-increment-x trait\n        // Coerce the data to have everything we need, with the same structure as a PC's weapon data\n        weapons = strikes.filter(action => action.traits.filter(trait => trait.name.startsWith(\"range-increment-\")).length).map(strike => {\n            return {\n                _id: strike.sourceId,\n                name: strike.name,\n                img: strike.imageUrl,\n                data: {\n                    range: strike.traits.filter(trait => trait.name.startsWith(\"range-increment-\"))[0].name.slice(16)\n                }\n            }\n        });\n    }\n\n    if (!weapons.length) {\n        ui.notifications.info(`You have no ranged weapons equipped`);\n    } else if (weapons.length == 1) {\n        return weapons[0];\n    } else {\n        return chooseWeapon(weapons);\n    }\n}\n\nasync function chooseWeapon(weapons) {\n    let weapon = await WeaponSelectDialog.getWeapon(weapons);\n    if (!weapon) {\n        ui.notifications.warn(\"No weapon selected\");\n    }\n    return weapon;\n}\n\nasync function getItem(id) {\n    const source = (await fromUuid(id)).toObject();\n    source.flags[\"pf2e-ranged-combat\"] = {\n        sourceId: id\n    };\n    return source;\n}","folder":null,"sort":0,"permission":{"default":0,"4siyeA20BbSN5bfQ":3},"flags":{}}
